---
title: "An introduction to the multiStateQTLExperiment class"
author:
  - "Christina B Azodi"
  - "Davis McCarthy"
package: multiStateQTLExperiment
date: "Last updated: 14 June 2022"
output:
    BiocStyle::html_document:
        toc: true
        toc_float: true
vignette: >
  %\VignetteIndexEntry{An introduction to the multiStateQTLExperiment class}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r knitr-options, echo = FALSE}
suppressPackageStartupMessages({
  devtools::load_all("/mnt/mcfiles/cazodi/Software/multiStateQTLExperiment")
  #library(multiStateQTLExperiment)
  #devtools::load_all(".")
})

knitr::opts_chunk$set(warning=FALSE, error=FALSE, message=FALSE, 
                      fig.height = 6, fig.width = 8)
```

# 1. Motivation

The `multiStateQTLExperiment` class is a Bioconductor container for storing and manipulating QTL summary statistics (effect sizes, standard errors, significance metrics) from multiple states (e.g., tissues, celltypes, environmental conditions). It extends the RangedSummarizedExperiment class, where rows represent QTL associations, columns represent states, and assays are the various summary statistics. Each row is named as "feature_id|variant_id", for example ENSG00000103888|rs112057726 or ENSG00000103888|15:81925049. This package provides methods for reading, merging, and subsetting multi-state QTL data. Further, as features generally are tested against multiple variants,multiStateQTLExperiment also provides methods for summarizing QTL statistics based by feature. 


# 2. Creating multiStateQTLExperiment instances

## Manual generation

`multiStateQTLExperiment` objects can be created by passing required information to the `multiStateQTLExperiment` function. Required information includes the assays *betas* and *error* and the rowData information *feature_id* and *variant_id*. Additional in the form of assays, rowData, colData, metadata, and dimension-reduction data can also be added to the object.

```{r create-mock-MSQE-manual}
set.seed(42)
nStates <- 6
nQTL <- 40

mockBeta <- mockBeta(nStates=nStates, nQTL=nQTL)
mockError <- mockError(nStates=nStates, nQTL=nQTL)
mockPval <- mockPval(nStates=nStates, nQTL=nQTL)

mock.states <- paste0("state_", c(1:nStates))
mock.feature_ids <- sample(c("A", "B", "C", "D", "E"), nQTL, replace=TRUE)
mock.variant_ids <- sample(seq(1:1e5), nQTL)

msqe <- multiStateQTLExperiment(assays = list(betas=mockBeta, 
                                              error=mockError, 
                                              pval=mockPval),
                                colData=DataFrame(state=mock.states),
                                rowData=DataFrame(feature_id=mock.feature_ids,
                                                  variant_id=mock.variant_ids),
                                metadata=list(study="mock-example"))
msqe
```

Note that a mock `multiStateQTLExperiment` object can also be generated automatically using the `mockMSQE` function:

```{r create-mock-MSQE-wrapper}
msqe <- mockMSQE(nStates=nStates, nQTL=nQTL)
msqe
```

## From QTL summary statistics for each state 

The `summaryStats_2_msqe()` function is a generic function to load QTL summary statistics from multiple files, where each file represents a state, and convert them into a `multiStateQTLExperiment` object. Because different QTL mapping software produce summary statistics in different formats, this function is flexible, allowing users to specify the column name or index where required data is stored. This function can also utilize parallel processing (cores available are automatically detected, see [vroom documentation](https://vroom.r-lib.org/index.html) for details. 

Required arguments:

  - input: A named list (name=`state`; value=`path`) or matrix with two columns (`state` and `path`) where the state is the desired name and the path is the full local path or the weblink to the summary statistics for that state. 
  - feature_id: The index or name of the column in the summary statistic files containing the feature ID
  - variant_id: The index or name of the column in the summary statistic files containing the variant ID
  - betas: The index or name of the column in the summary statistic files containing the estimated betas
  - error: The index or name of the column in the summary statistic files containing the estimated beta errors

Optional arguments:
  - na.rm: Logical. To remove QTL tests (rows) with missing data for any state.
  - pval: The index or name of the column in the summary statistic files containing test statistics.
  - n_max: The number of rows to read from each file (useful for testing purposes)
  
  
For example, we can load summary statistics from the [EBI eQTL database](https://www.ebi.ac.uk/eqtl/Data_access/):

```{r demo-summaryStats_2_msqe}
input_web <- list(lung="http://ftp.ebi.ac.uk/pub/databases/spot/eQTL/sumstats/GTEx/tx/GTEx_tx_lung.all.tsv.gz",
                  thyroid="http://ftp.ebi.ac.uk/pub/databases/spot/eQTL/sumstats/GTEx/tx/GTEx_tx_thyroid.all.tsv.gz",
                  spleen="http://ftp.ebi.ac.uk/pub/databases/spot/eQTL/sumstats/GTEx/tx/GTEx_tx_spleen.all.tsv.gz",
                  blood="http://ftp.ebi.ac.uk/pub/databases/spot/eQTL/sumstats/GTEx/tx/GTEx_tx_blood.all.tsv.gz")

msqe4 <- summaryStats_2_msqe(input_web, 
                             feature_id="molecular_trait_id",
                             variant_id="rsid", 
                             betas = "beta", 
                             error = "se",
                             pval = "pvalue", 
                             n_max=10000,
                             verbose = TRUE)
msqe4
head(betas(msqe4))
```

## From mashr data format

A convenience function is also available to convert `mash` objects into `MSQE` objects.

```{r mashr-to-msqe}
mashr_sim <- mashr::simple_sims(nQTL,5,1) 

msqe2 <- mash_2_msqe(mashr_sim, rowData=DataFrame(feature_id=row.names(mashr_sim$Bhat),
                                                 variant_id=sample(seq(1:1e5), nQTL)))
msqe2
```

# 3. Basic object manipulation

Any operation that can be applied to a RangedSummarizedExperiment is also applicable to any instance of a `multiStateQTLExperiment`. This includes access to assay data via assay(), column metadata with colData(), etc. 

```{r show-dim}
dim(msqe4)
```

```{r show-state-names}
colnames(msqe4)
```

```{r show-feature-snp-ids}
head(rowData(msqe4))
```

```{r show-bind-functions}
dim(cbind(msqe4, msqe4))
```

```{r show-subset-functions}
msqe.subset <- msqe[rowData(msqe)$feature_id == "geneA", ]
dim(msqe.subset)

msqe.subset <- msqe[, c("state1", "state2")]
dim(msqe.subset)

msqe.subset <- subset(msqe, , sample_size > 100)
dim(msqe.subset)
```


# 4. Named assay conventions

In the `multiStateQTLExperiment`, required information includes the assays *betas* and *error* and the rowData information *feature_id* and *variant_id*. Beyond these features, users can assign arbitrary names to assay entries. For example, multi-test adjusted summary statistics can be added using a setter method and : after applying a multi-test adjustment method (e.g. mashr) to the MSQE, To assist interoperability between packages, we provide some suggestions for what the names should be for particular types of data:


Each of these suggested names has an appropriate getter/setter method for convenient manipulation of the `multiStateQTLExperiment`. For example, we can take gtex_slope and assign it to beta instead:

```{r set-as-common-assay}
msqe <- multiStateQTLExperiment(assays = list(betas=mockBeta, 
                                              error=mockError, 
                                              adj.betas=mockBeta*0.5, 
                                              adj.error=mockError*0.5),
                                rowData=DataFrame(feature_id=mock.feature_ids,
                                                  variant_id=mock.variant_ids))
names(assays(msqe))

betas(msqe)[1:4,1:4]
assay(msqe, "adj.betas")[1:4,1:4]
```


# 4. Adding low-dimensional representations to MSQE

We can add one or multiple low-dimensional representations to the `MSQE ` object with the `reducedDim` and `reducedDims` methods, respectively. The coordinates for all representations can be retrieved from a `multiStateQTLExperiment` with reducedDims() or one at a time by name/index with reducedDim(). Each row of the coordinate matrix is assumed to correspond to a state while each column represents a dimension.

```{r set-reducedDims}
pca_data <- prcomp(t(betas(msqe)), rank=50)
pca_data2 <- prcomp(t(betas(msqe)), rank=10)

reducedDims(msqe) <- list(PCA_50=pca_data$x, PCA_10=pca_data2$x)
reducedDims(msqe)
```


Any subsetting by column of msqe_sub will also lead to subsetting of the dimensionality reduction results by state. This is convenient as it ensures our low-dimensional results are always synchronized with the QTL data.

```{r show-subset-of-PCA}
dim(reducedDim(msqe, "PCA_50"))
dim(reducedDim(msqe[, 1:4], "PCA_50"))
```




# Session Info

```{r session-info}
sessionInfo()
```

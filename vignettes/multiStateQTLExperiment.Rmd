---
title: "An introduction to the multiStateQTLExperiment class"
author:
  - "Christina B Azodi"
  - "Davis McCarthy"
package: multiStateQTLExperiment
date: "Last updated: 14 June 2022"
output:
    BiocStyle::html_document:
        toc: true
        toc_float: true
vignette: >
  %\VignetteIndexEntry{An introduction to the multiStateQTLExperiment class}
  %\VignetteEngine{knitr::rmarkdown}
  \usepackage[utf8]{inputenc}
---

```{r knitr-options, echo = FALSE}
suppressPackageStartupMessages({
  library(multiStateQTLExperiment)
  #devtools::load_all(".")
})

knitr::opts_chunk$set(warning=FALSE, error=FALSE, message=FALSE, 
                      fig.height = 6, fig.width = 8)
```

# 1. Motivation

The `multiStateQTLExperiment` class is a Bioconductor container for storing and manipulating QTL summary statistics (effect sizes, standard errors, significance metrics) from multiple states (e.g., tissues, celltypes, environmental conditions). It extends the RangedSummarizedExperiment class, where rows represent QTL associations, columns represent states, and assays are the various summary statistics. Each row is named as "feature_id|variant_id", for example ENSG00000103888|rs112057726 or ENSG00000103888|15:81925049. This package provides methods for reading, merging, and subseting multi-state QTL data. Further, as features generally are tested against multiple variants,multiStateQTLExperiment also provides methods for summarizing QTL statistics based by feature. 


# 2. Creating multiStateQTLExperiment instances

## Manual generation

`multiStateQTLExperiment` objects can be created by passing required information to the `multiStateQTLExperiment` function. Required information includes the assays *betas* and *error* and the rowData information *feature_id* and *variant_id*. Additional assays, rowData, colData, metadata, and dimension-reduction data can also be included.


```{r create-mock-MSQE-manual}
set.seed(42)
nStates <- 6
nQTL <- 40

mockBeta <- mockBeta(nStates=nStates, nQTL=nQTL)
mockSE <- mockSE(nStates=nStates, nQTL=nQTL)
mockPval <- mockPval(nStates=nStates, nQTL=nQTL)

mock.states <- paste0("state_", LETTERS[seq(from = 1, to = nStates)])
mock.feature_ids <- sample(paste0("gene", LETTERS[seq(from = 1, to = 10)]), 
                              nQTL, replace=TRUE)
mock.variant_ids <- paste0("var", sample(seq(1e3:1e5), nQTL))

msqe <- multiStateQTLExperiment(assays = list(betas=mockBeta, 
                                              error=mockSE, 
                                              pval=mockPval),
                                colData=DataFrame(state=mock.states),
                                rowData=DataFrame(feature_id=mock.feature_ids,
                                                  variant_id=mock.variant_ids),
                                metadata=list(study="mock-example"))
msqe
```

Note that a mock `multiStateQTLExperiment` object can also be generated automatically using the `mockMSQE` function:

```{r create-mock-MSQE-wrapper}
msqe <- mockMSQE(nStates=nStates, nQTL=nQTL)
msqe
```

## Automate MSQE generation from QTL mapping results

`multiStateQTLExperiment` objects can be generated using one of a number of import functions that automatically convert QTL summary statistics from common QTL mapping software into `multiStateQTLExperiment` objects.

These include:
  
  - limix
  - GTEx


## Automate MSQE generation from multi-state QTL correction results

Finally, `multiStateQTLExperiment` objects can be generated using one of a number of import functions that automatically convert multi-state corrected QTL summary statistics from common software into `multiStateQTLExperiment` objects.

These include:

  - mashr

# 3. Basic object manipulation

Any operation that can be applied to a RangedSummarizedExperiment is also applicable to any instance of a `multiStateQTLExperiment`. This includes access to assay data via assay(), column metadata with colData(), etc. 

```{r show-dim}
dim(msqe)
```

```{r show-state-names}
colnames(msqe)
```

```{r show-feature-snp-ids}
head(rowData(msqe))
```

```{r show-bind-functions}
dim(rbind(msqe, msqe))
dim(cbind(msqe, msqe))
```

```{r show-subset-functions}
msqe.subset <- msqe[rowData(msqe)$feature_id == "geneA", ]
dim(msqe.subset)

msqe.subset <- msqe[, c("state1", "state2")]
dim(msqe.subset)

msqe.subset <- subset(msqe, , sample_size > 100)
dim(msqe.subset)
```

# 4. Named assay conventions

In the `multiStateQTLExperiment`, required information includes the assays *betas* and *error* and the rowData information *feature_id* and *variant_id*. Beyond these features, users can assign arbitrary names to assay entries. For example, multi-test adjusted summary statistics can be added using a setter method and : after applying a multi-test adjustment method (e.g. mashr) to the MSQE, To assist interoperability between packages, we provide some suggestions for what the names should be for particular types of data:


Each of these suggested names has an appropriate getter/setter method for convenient manipulation of the `multiStateQTLExperiment`. For example, we can take gtex_slope and assign it to beta instead:

```{r set-as-common-assay}
msqe <- multiStateQTLExperiment(assays = list(betas=mockBeta, 
                                              error=mockSE, 
                                              adj.betas=mockBeta*0.5, 
                                              adj.error=mockSE*0.5),
                                rowData=DataFrame(feature_id=mock.feature_ids,
                                                  variant_id=mock.variant_ids))
names(assays(msqe))

betas(msqe)[1:4,1:4]
assay(msqe, "adj.betas")[1:4,1:4]
```


# 4. Adding low-dimensional representations to MSQE

We can add one or multiple low-dimensional representations to the `MSQE ` object with the `reducedDim` and `reducedDims` methods, respectively. The coordinates for all representations can be retrieved from a `multiStateQTLExperiment` with reducedDims() or one at a time by name/index with reducedDim(). Each row of the coordinate matrix is assumed to correspond to a state while each column represents a dimension.

```{r set-reducedDims}
pca_data <- prcomp(t(betas(msqe)), rank=50)
pca_data2 <- prcomp(t(betas(msqe)), rank=10)

reducedDims(msqe) <- list(PCA_50=pca_data$x, PCA_10=pca_data2$x)
reducedDims(msqe)
```


Any subsetting by column of msqe_sub will also lead to subsetting of the dimensionality reduction results by state. This is convenient as it ensures our low-dimensional results are always synchronized with the QTL data.

```{r show-subset-of-PCA}
dim(reducedDim(msqe, "PCA_50"))
dim(reducedDim(msqe[, 1:4], "PCA_50"))
```




# Session Info

```{r session-info}
sessionInfo()
```
